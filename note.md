+ C1_W1:
  + plt.legend()是一个函数，用于在图形中添加图例，图例通常是用来解释图中各种元素代表的含义和标签，通常与图形中的系列进行对应
  + plt.show() 用于显示图形界面
  + cost函数里面的部分是  （预测的y减去真实的y）的平方，然后把这m个全部加起来，最后再乘上一个1/(2*m)
  + lab_utils_uni 解析
    + plt_house_x(X,y,f_wb=None,ax=None )  :
      + 参数分析：
        + X表示房屋大小的特征数据，通常是一个一维数组或者列表
        + y 表示房屋价格的目标数据，通常是一个一维数组或列表，与X对应
        + f_wb （可选），预测值，及房屋价格的预测，默认是None，表示不绘制预测值
        + ax，（可选），用于绘图的轴对象，如果未提供，则会创建一个新的图形和轴
      + 内部逻辑分析：
        + 首先函数提供了一个轴对象ax
        + 使用scatter方法在轴上绘制房屋大小X，和房屋价格y的散点图，使用红叉来表示实际值
        + 设置图形标题和x轴标签，y轴标签
        + 如果f_wb不是空值，就绘制预测值，使用plot方法，plot(x轴上的数据， y轴上的数据， c是指定绘制曲线的颜色， label是设置曲线的标签，用于后续在图例中显示)
      + 概括：先生成已知的x，y的散点图，在生成预测的曲线
    + mk_cost_lines(x,y,w,b,ax):
      + 参数分析：
        + x，y分别是特征数据和目标数据，表示房屋大小和房屋价格
        + w，b分别是线性回归模型的权重和偏置，用于计算预测值
        + ax 用于绘制图形的轴对象
      + 内部逻辑：
        + 假设x是[1000,1500,2000],y=[250000,350000,450000] 那么zip(x,y)将会返回一个打包的迭代器，元素依次是 (1000,250000),(1500,350000),(2000,450000)。所以p[0] 代表特征数据，p[1]代表目标数据
        + 使用特征数据p[0],计算对应的预测值f_wb_p
        + 计算该数据点的成本值，即预测值与实际值之间的差的平方的一半
        + 使用vlines方法在图中绘制垂直于数据点的成本线，线的起点是数据点的x坐标，终点是对应的预测值f_wb_p，线的颜色是深紫色
          + vlines函数详解：
            + ax.vlines(x, ymin, ymax, **kwargs)
            + x表示垂直线的x坐标值或者一个包含了多个x坐标值的数组，如果是一个数组，则会在每一个x坐标值处绘制一条垂直线
            + ymin，ymax分别表示每条垂直线的起点和终点的y坐标值，可以是一个单独的值，或者与x相同长度的数组，分别对应于每个x坐标值处的起点和终点的y坐标值
            + **kwargs 是一系列可选参数，用于指定垂直线的属性，比如线的颜色，线型，线宽等
            + 在mk_cost_lines中，vlines被用来在图中绘制垂直于数据点的成本线
            + p[0] 是数据点的x坐标值
            + p[1] 是数据点的y坐标值，也是成本线的起点的y坐标值
            + f_wb_p 是成本线的终点的y坐标值，即对应于数据点的预测值
            + lw=3指定了成本线的线宽是3
            + color=dlpurple 指定了成本线的颜色为深紫色
            + ls='dotted' 指定了成本线的线型为虚线
            + label=label设置了成本线的标签，用于后续在图例中显示
        + 使用annotate方法在图中标记成本值，标记位置为成本值中点，内容是成本值
          + annotate方法详解：
            + 它是Matplotlib中用于在图中添加注释的函数，它允许你在图中的特定位置添加文本，箭头或其他注释元素
            + ax.annotate(text,xy,xytext=None,arrowprops=None,**kwargs)
              + 参数分析：
                + text 是要添加的文本内容
                + xy 是注释文本的目标位置，一个包含了目标位置的二维坐标元组‘（x，y）’
                + xytext 是注释文本的文本位置，一个包含了文本位置的二维坐标元组‘（x，y）’，如果不提供，则默认为xy
                + arrowprops 是一个字典，用于配置注释箭头的属性，比如箭头样式，颜色，宽度等
                + **kwargs 是一系列其他可选参数，用于配置注释文本的属性，比如文本颜色，字体大小，对齐方式等
              + 代码分析：
                + f'{c_p_text:0.0f}' 是要显示的成本值，使用了python格式化字符串来保留成本值的整数部分
                + xy=cxy 指定了注释文本的目标位置，即成本线的中点位置
                + xycoords = 'data' 表示目标位置是基于数据坐标体系的,这意味着在annotate方法中指定的xy参数是基于数据坐标系的位置，即用数据 的实际值来确定位置
                + color=dlpurple 指定了注释文本的颜色为深紫色
                + xytext=(5,0) 设置了注释文本的文本位置的偏移量，相对于目标位置。通过设置这个参数，你可以在目标位置的基础上，对文本位置进行微调或者偏移。xytext接收一个二维坐标元组，其中分别表示文本在x和y方向上的偏移量，这个偏移量是相对于目标位置来说的。通过设置偏移量，能精准控制注释文本的位置，以便更好地于数据点对齐或者避免重叠
                + textcoords='offset points'，这意味着使用偏移量来设置注释文本位置时，偏移量是相对某个参考点而言的，而不是相对于整个图形的坐标系。具体来说，偏移量指定了注释文本相对于某个参考点的位移量，而参考点通常是数据坐标系中的一个数据点，其坐标由‘xy’参数指定，这样一来，注释文本的最终位置是参考点设置加上偏移量的结果
        + 将每个数据点的成本值累加，计算总的成本值ctot
        + 最后将总的成本值ctot和成本函数的公式字符串cstr添加到图中，用于显示成本函数的形式和总的成本值
      + 概括：
        + mk_cost_lines 函数的作用是在图中绘制垂直于数据点的成本线，并在每个成本上标处相应的成本值，以及在图中显示总的成本值和成本函数的形式
  + plt_intution(x_train,y_train)
    + 参数分析：
      + 接收训练数据x_train,和对应的目标值y_train 作为输入参数
    + 内部逻辑：
      + 定义了参数w的取值范围w_range
      + 用tmp_b定义了参数b的初始值，初始值为100
      + w_array = np.arrange(*w_range,5),这里使用np.arrange函数创建了一个包含一系列参数w的值的数组，这些值位于之前定义的 w_range 范围内，步长为5
      + cost = np.zeros_like(w_array):这里创建了一个与w_array 大小相同的数组，用于存储不同参数w 对应的成本函数值
      + 循环遍历参数w的数组
      + 获取每次循环中的参数w的值
      + cost[i] = compute_cost(x_train，y_train，tmp_w，tmp_b)：这里调用一个名为compute_cost 的函数，用于计算给定参数w和b下的成本函数值，并将结果存储在cost数组中的相应位置
      + @interact(w=(*w_range,10),continuous_update=False):这是一个装饰器，用于创建一个交互式组件，允许用户通过滑块调整参数w的值，滑块的取值范围 由w_range定义，步长为10，参数continuous_update=False表示在滑动滑块时不实时更新
      + 嵌套函数func 接收一个参数w，默认值是150
      + f_wb = np.dot(x_train,w) + tmp_b:这里计算了在当前参数w和b下，模型对训练数据x_train 的预测结果，并将结果存储在f_wb中
      + fig,ax=plt.subplots(1,2,constrained_layout=True,figsize=(8,4)):这里创建了一个包含两个子图 的图形对象，使用plt.subplots 函数，参数constrained_layout=True 用于自动调整子图布局以防止重叠，参数figsize=(8,4) 指定了图形的大小
      + mk_cost_lines(x_train,y_train,w,tmp_b,ax[0]):这里调用了mk_cost_lines 函数，用于在左侧子图中绘制成本函数的垂直线，表示每个数据点对应的成本
      + plt_house_x,这里调用了plt_house_x函数，在左侧子图中绘制了房屋价格数据的散点图，并标记了模型的预测结果
      + ax[1].plot(w_array,cost): 这里再右侧子图中绘制了成本函数随参数w 变化的曲线图
      + cur_cost = compute_cost(x_train,y_train,w,tmp_b) 这里计算了当前参数w和b下的成本函数值，并将结果存储在cur_cost 中
      + ax[1].scatter(w,cur_cost,s=100,color=dldarked,zorder=10,label=f"cost at w={w}"):这里在右侧子图中标出了当前参数值下的成本值，并用散点表示
  + plt_stationary(x_train,y_train)
    + 参数分析：
      + 接收两个训练数组x，y
    + 内部逻辑：
      + 设置图形：
        + 创建一个大小为（9，8）的新图形（figure=（9，8）），设置图形的背景颜色为白色（fig.set_facecolor('#ffffff'),并将工具栏位置设置为顶部
        + 使用GridSpec 创建一个 2*2的子网方格，通过fig.add_subplot() 函数 向图形添加子图，并将其保存在名为ax0，ax1和ax2的变量中
      + 设置数据范围和线性空间：
        + 定义了一些用于等高线和3D绘图的范围和线性空间
      + 计算成本：
        + 使用 compute_cost 函数计算给定参数下的成本
      + 绘制模型w成本：
        + 计算模型预测值并绘制成本线和数据点
        + 使用 meshgrid()函数生成w和b的网格，并计算每个网格点上的成本值，这些成本值被用来绘制等高线图和3D曲面图
      + 绘制等高线图：
        + 使用contour() 函数绘制成本函数的等高线图
        + 设置图表题，轴标签和限制轴范围
        + 绘制当前参数的成本点
      + 绘制3D成本图：
        + 使用plot_surface() 函数绘制成本函数的三维曲面
        + 设置轴标签和标题，并初始化视角
      + 返回图形，子图和一组对象列表（散点，水平线和垂直线），用于交互式操作
  + plt_update_onclick(class)
    + 构造函数分析：
      + 这个类有一个构造函数，它接收fig,ax,x_train,y_train 和dyn_items 作为参数，在构造函数中，它将传入的参数保存为类的属性，并使用 mpl_connect() 函数将点击事件与self 绑定，以便调用 __call__() 方法
      + dyn_items 是用来存储动态元素的列表，这些元素在点击事件触发后需要被更新或者重新绘制的。在本代码中，dyn_items 包含了曲线图和三维图中的一些动态元素，例如散点，水平线，垂直线，注释等
    + __call__ 方法：
      + 逻辑解析：
        + 该方法实现了当点击事件发生时的处理逻辑，首先它检查点击事件是否发生在self.ax[1] 这个子图上，如果是，则获取点击事件的坐标 ws,bs,然后计算对应的成本 cst
        + 接着，它清除了self.ax[0] 上的内容，并重新绘制了曲线图，然后移除了self.dyn_items 中的所有元素，并重新在self.ax[1],self.ax[2] 上添加了新的元素，包括散点，水平线，垂直线，注释和三维散点，最后更新了self.dyn_items 并调用了self.fig.canvas.draw() 来更新图形
    + 作用：
      + 实现一个点击交互功能，当用户在图形中点击某个点时，会根据点击位置重新绘制图形，并显示相关信息
  + soup_bowl:创建一个带有3D投影的图形
    + 逻辑解析：
      + 创建一个新的图形对象fig, 设置其大小是（8，8）英寸
      + ax = fig.add_subplot() 在图形中添加一个子图ax，设置投影类型为3D
      + 设置图形的一些配置，包括将坐标轴背景色设为透明，取消Z轴标签的旋转，并设置初始视角
      + np.linspace() 创建两个等间距的一维数组w和b，用于给w和b赋值
      + 遍历数组w和b，计算代价函数的值，并将结果保存到二维数组z中
      + np.meshgrid() 创建网格W和B ，用于绘制3D函数
      + ax.plot_surface() ,ax.plot_wireframe() 绘制了碗状代价函数的曲面图和线框图
      + 然后设置X，Y，Z轴的标签，以及图形的标题
      + plt.show() 收尾，展示图形
  + inbounds: 用于**检查**两个点a 和 b 是否同时位于**指定的x和y范围内**
    + 参数：
      + a，b 表示点坐标的二维数组，xlim，ylim分别是x和y的范围，它们都是包含两个元素的数组，它们其中的两个元素的数组分别表示范围的下限和上限。
    + 逻辑分析：
      + 将xlim和ylim 解包成下限和上限的变量 xlow,xhigh;ylow,yhigh
      + 将a和b 解包成x和y坐标的变量：ax，ay；bx，by
      + 一个条件语句，用于检查a和b是否同时位于指定的x和y范围内，它使用了四个逻辑表达式，分别检查点a和b的x和y坐标是否都位于相应的范围内，如果所有的条件都成立，即点a和b都在指定的范围内，那么就返回True。否则就返回False
  + plt_contour_wgrad:用于绘制轮廓图并显示梯度下降路径
    + 参数：
      + 输入数据x和y，梯度下降路径hist，绘制轮廓图的ax，以及一些其他参数：w_range，b_range, contours
    + 内部逻辑：
      + 生成一个网格，覆盖了给定的w_range ,b_range 范围内的所有可能的参数值，然后通过compute_cost() 函数计算了每个参数组合的成本值，结果保存在数组z中
      + 使用ax.contour() 函数绘制了轮廓图，并通过contours 参数来绘制特定的等高线，然后使用ax.clabel() 添加了轮廓线上的标签，并设置了轴标签和标题
      + 绘制了最终梯度下降路径的水平和垂直虚线，以标记最终达到的点（w_final, b_final）
      + 这部分代码根据梯度下降路径hist绘制了箭头，表示路径的方向，箭头之间的间隔由参数step控制，resolution 参数用于控制是否绘制箭头，以避免过于拥挤
      + 最后返回空
      + 