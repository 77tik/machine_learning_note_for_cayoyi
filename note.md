+ C1_W1:
  + plt.legend()是一个函数，用于在图形中添加图例，图例通常是用来解释图中各种元素代表的含义和标签，通常与图形中的系列进行对应
  + plt.show() 用于显示图形界面
  + cost函数里面的部分是  （预测的y减去真实的y）的平方，然后把这m个全部加起来，最后再乘上一个1/(2*m)
  + lab_utils_uni 解析
    + plt_house_x(X,y,f_wb=None,ax=None )  :
      + 参数分析：
        + X表示房屋大小的特征数据，通常是一个一维数组或者列表
        + y 表示房屋价格的目标数据，通常是一个一维数组或列表，与X对应
        + f_wb （可选），预测值，及房屋价格的预测，默认是None，表示不绘制预测值
        + ax，（可选），用于绘图的轴对象，如果未提供，则会创建一个新的图形和轴
      + 内部逻辑分析：
        + 首先函数提供了一个轴对象ax
        + 使用scatter方法在轴上绘制房屋大小X，和房屋价格y的散点图，使用红叉来表示实际值
        + 设置图形标题和x轴标签，y轴标签
        + 如果f_wb不是空值，就绘制预测值，使用plot方法，plot(x轴上的数据， y轴上的数据， c是指定绘制曲线的颜色， label是设置曲线的标签，用于后续在图例中显示)
      + 概括：先生成已知的x，y的散点图，在生成预测的曲线
    + mk_cost_lines(x,y,w,b,ax):
      + 参数分析：
        + x，y分别是特征数据和目标数据，表示房屋大小和房屋价格
        + w，b分别是线性回归模型的权重和偏置，用于计算预测值
        + ax 用于绘制图形的轴对象
      + 内部逻辑：
        + 假设x是[1000,1500,2000],y=[250000,350000,450000] 那么zip(x,y)将会返回一个打包的迭代器，元素依次是 (1000,250000),(1500,350000),(2000,450000)。所以p[0] 代表特征数据，p[1]代表目标数据
        + 使用特征数据p[0],计算对应的预测值f_wb_p
        + 计算该数据点的成本值，即预测值与实际值之间的差的平方的一半
        + 使用vlines方法在图中绘制垂直于数据点的成本线，线的起点是数据点的x坐标，终点是对应的预测值f_wb_p，线的颜色是深紫色
          + vlines函数详解：
            + ax.vlines(x, ymin, ymax, **kwargs)
            + x表示垂直线的x坐标值或者一个包含了多个x坐标值的数组，如果是一个数组，则会在每一个x坐标值处绘制一条垂直线
            + ymin，ymax分别表示每条垂直线的起点和终点的y坐标值，可以是一个单独的值，或者与x相同长度的数组，分别对应于每个x坐标值处的起点和终点的y坐标值
            + **kwargs 是一系列可选参数，用于指定垂直线的属性，比如线的颜色，线型，线宽等
            + 在mk_cost_lines中，vlines被用来在图中绘制垂直于数据点的成本线
            + p[0] 是数据点的x坐标值
            + p[1] 是数据点的y坐标值，也是成本线的起点的y坐标值
            + f_wb_p 是成本线的终点的y坐标值，即对应于数据点的预测值
            + lw=3指定了成本线的线宽是3
            + color=dlpurple 指定了成本线的颜色为深紫色
            + ls='dotted' 指定了成本线的线型为虚线
            + label=label设置了成本线的标签，用于后续在图例中显示
        + 使用annotate方法在图中标记成本值，标记位置为成本值中点，内容是成本值
          + annotate方法详解：
            + 它是Matplotlib中用于在图中添加注释的函数，它允许你在图中的特定位置添加文本，箭头或其他注释元素
            + ax.annotate(text,xy,xytext=None,arrowprops=None,**kwargs)
              + 参数分析：
                + text 是要添加的文本内容
                + xy 是注释文本的目标位置，一个包含了目标位置的二维坐标元组‘（x，y）’
                + xytext 是注释文本的文本位置，一个包含了文本位置的二维坐标元组‘（x，y）’，如果不提供，则默认为xy
                + arrowprops 是一个字典，用于配置注释箭头的属性，比如箭头样式，颜色，宽度等
                + **kwargs 是一系列其他可选参数，用于配置注释文本的属性，比如文本颜色，字体大小，对齐方式等
              + 代码分析：
                + f'{c_p_text:0.0f}' 是要显示的成本值，使用了python格式化字符串来保留成本值的整数部分
                + xy=cxy 指定了注释文本的目标位置，即成本线的中点位置
                + xycoords = 'data' 表示目标位置是基于数据坐标体系的,这意味着在annotate方法中指定的xy参数是基于数据坐标系的位置，即用数据 的实际值来确定位置
                + color=dlpurple 指定了注释文本的颜色为深紫色
                + xytext=(5,0) 设置了注释文本的文本位置的偏移量，相对于目标位置。通过设置这个参数，你可以在目标位置的基础上，对文本位置进行微调或者偏移。xytext接收一个二维坐标元组，其中分别表示文本在x和y方向上的偏移量，这个偏移量是相对于目标位置来说的。通过设置偏移量，能精准控制注释文本的位置，以便更好地于数据点对齐或者避免重叠
                + textcoords='offset points'，这意味着使用偏移量来设置注释文本位置时，偏移量是相对某个参考点而言的，而不是相对于整个图形的坐标系。具体来说，偏移量指定了注释文本相对于某个参考点的位移量，而参考点通常是数据坐标系中的一个数据点，其坐标由‘xy’参数指定，这样一来，注释文本的最终位置是参考点设置加上偏移量的结果
        + 将每个数据点的成本值累加，计算总的成本值ctot
        + 最后将总的成本值ctot和成本函数的公式字符串cstr添加到图中，用于显示成本函数的形式和总的成本值
      + 概括：
        + mk_cost_lines 函数的作用是在图中绘制垂直于数据点的成本线，并在每个成本上标处相应的成本值，以及在图中显示总的成本值和成本函数的形式
  + plt_intution(x_train,y_train)
    + 参数分析：
      + 接收训练数据x_train,和对应的目标值y_train 作为输入参数
    + 内部逻辑：
      + 定义了参数w的取值范围w_range
      + 用tmp_b定义了参数b的初始值，初始值为100
      + w_array = np.arrange(*w_range,5),这里使用np.arrange函数创建了一个包含一系列参数w的值的数组，这些值位于之前定义的 w_range 范围内，步长为5
      + cost = np.zeros_like(w_array):这里创建了一个与w_array 大小相同的数组，用于存储不同参数w 对应的成本函数值
      + 循环遍历参数w的数组
      + 获取每次循环中的参数w的值
      + cost[i] = compute_cost(x_train，y_train，tmp_w，tmp_b)：这里调用一个名为compute_cost 的函数，用于计算给定参数w和b下的成本函数值，并将结果存储在cost数组中的相应位置
      + @interact(w=(*w_range,10),continuous_update=False):这是一个装饰器，用于创建一个交互式组件，允许用户通过滑块调整参数w的值，滑块的取值范围 由w_range定义，步长为10，参数continuous_update=False表示在滑动滑块时不实时更新
      + 嵌套函数func 接收一个参数w，默认值是150
      + f_wb = np.dot(x_train,w) + tmp_b:这里计算了在当前参数w和b下，模型对训练数据x_train 的预测结果，并将结果存储在f_wb中
      + fig,ax=plt.subplots(1,2,constrained_layout=True,figsize=(8,4)):这里创建了一个包含两个子图 的图形对象，使用plt.subplots 函数，参数constrained_layout=True 用于自动调整子图布局以防止重叠，参数figsize=(8,4) 指定了图形的大小
      + mk_cost_lines(x_train,y_train,w,tmp_b,ax[0]):这里调用了mk_cost_lines 函数，用于在左侧子图中绘制成本函数的垂直线，表示每个数据点对应的成本
      + plt_house_x,这里调用了plt_house_x函数，在左侧子图中绘制了房屋价格数据的散点图，并标记了模型的预测结果
      + ax[1].plot(w_array,cost): 这里再右侧子图中绘制了成本函数随参数w 变化的曲线图
      + cur_cost = compute_cost(x_train,y_train,w,tmp_b) 这里计算了当前参数w和b下的成本函数值，并将结果存储在cur_cost 中
      + ax[1].scatter(w,cur_cost,s=100,color=dldarked,zorder=10,label=f"cost at w={w}"):这里在右侧子图中标出了当前参数值下的成本值，并用散点表示
  + plt_stationary(x_train,y_train)
    + 参数分析：
      + 接收两个训练数组x，y
    + 内部逻辑：
      + 设置图形：
        + 创建一个大小为（9，8）的新图形（figure=（9，8）），设置图形的背景颜色为白色（fig.set_facecolor('#ffffff'),并将工具栏位置设置为顶部
        + 使用GridSpec 创建一个 2*2的子网方格，通过fig.add_subplot() 函数 向图形添加子图，并将其保存在名为ax0，ax1和ax2的变量中
      + 设置数据范围和线性空间：
        + 定义了一些用于等高线和3D绘图的范围和线性空间
      + 计算成本：
        + 使用 compute_cost 函数计算给定参数下的成本
      + 绘制模型w成本：
        + 计算模型预测值并绘制成本线和数据点
        + 使用 meshgrid()函数生成w和b的网格，并计算每个网格点上的成本值，这些成本值被用来绘制等高线图和3D曲面图
      + 绘制等高线图：
        + 使用contour() 函数绘制成本函数的等高线图
        + 设置图表题，轴标签和限制轴范围
        + 绘制当前参数的成本点
      + 绘制3D成本图：
        + 使用plot_surface() 函数绘制成本函数的三维曲面
        + 设置轴标签和标题，并初始化视角
      + 返回图形，子图和一组对象列表（散点，水平线和垂直线），用于交互式操作
  + plt_update_onclick(class)
    + 构造函数分析：
      + 这个类有一个构造函数，它接收fig,ax,x_train,y_train 和dyn_items 作为参数，在构造函数中，它将传入的参数保存为类的属性，并使用 mpl_connect() 函数将点击事件与self 绑定，以便调用 __call__() 方法
      + dyn_items 是用来存储动态元素的列表，这些元素在点击事件触发后需要被更新或者重新绘制的。在本代码中，dyn_items 包含了曲线图和三维图中的一些动态元素，例如散点，水平线，垂直线，注释等
    + __call__ 方法：
      + 逻辑解析：
        + 该方法实现了当点击事件发生时的处理逻辑，首先它检查点击事件是否发生在self.ax[1] 这个子图上，如果是，则获取点击事件的坐标 ws,bs,然后计算对应的成本 cst
        + 接着，它清除了self.ax[0] 上的内容，并重新绘制了曲线图，然后移除了self.dyn_items 中的所有元素，并重新在self.ax[1],self.ax[2] 上添加了新的元素，包括散点，水平线，垂直线，注释和三维散点，最后更新了self.dyn_items 并调用了self.fig.canvas.draw() 来更新图形
    + 作用：
      + 实现一个点击交互功能，当用户在图形中点击某个点时，会根据点击位置重新绘制图形，并显示相关信息
  + soup_bowl:创建一个带有3D投影的图形
    + 逻辑解析：
      + 创建一个新的图形对象fig, 设置其大小是（8，8）英寸
      + ax = fig.add_subplot() 在图形中添加一个子图ax，设置投影类型为3D
      + 设置图形的一些配置，包括将坐标轴背景色设为透明，取消Z轴标签的旋转，并设置初始视角
      + np.linspace() 创建两个等间距的一维数组w和b，用于给w和b赋值
      + 遍历数组w和b，计算代价函数的值，并将结果保存到二维数组z中
      + np.meshgrid() 创建网格W和B ，用于绘制3D函数
      + ax.plot_surface() ,ax.plot_wireframe() 绘制了碗状代价函数的曲面图和线框图
      + 然后设置X，Y，Z轴的标签，以及图形的标题
      + plt.show() 收尾，展示图形
  + inbounds: 用于**检查**两个点a 和 b 是否同时位于**指定的x和y范围内**
    + 参数：
      + a，b 表示点坐标的二维数组，xlim，ylim分别是x和y的范围，它们都是包含两个元素的数组，它们其中的两个元素的数组分别表示范围的下限和上限。
    + 逻辑分析：
      + 将xlim和ylim 解包成下限和上限的变量 xlow,xhigh;ylow,yhigh
      + 将a和b 解包成x和y坐标的变量：ax，ay；bx，by
      + 一个条件语句，用于检查a和b是否同时位于指定的x和y范围内，它使用了四个逻辑表达式，分别检查点a和b的x和y坐标是否都位于相应的范围内，如果所有的条件都成立，即点a和b都在指定的范围内，那么就返回True。否则就返回False
  + plt_contour_wgrad:用于绘制轮廓图并显示梯度下降路径
    + 参数：
      + 输入数据x和y，梯度下降路径hist，绘制轮廓图的ax，以及一些其他参数：w_range，b_range, contours
    + 内部逻辑：
      + 生成一个网格，覆盖了给定的w_range ,b_range 范围内的所有可能的参数值，然后通过compute_cost() 函数计算了每个参数组合的成本值，结果保存在数组z中
      + 使用ax.contour() 函数绘制了轮廓图，并通过contours 参数来绘制特定的等高线，然后使用ax.clabel() 添加了轮廓线上的标签，并设置了轴标签和标题
      + 绘制了最终梯度下降路径的水平和垂直虚线，以标记最终达到的点（w_final, b_final）
      + 这部分代码根据梯度下降路径hist绘制了箭头，表示路径的方向，箭头之间的间隔由参数step控制，resolution 参数用于控制是否绘制箭头，以避免过于拥挤
      + 最后返回空
  + plt_divergence:用于绘制学习率过大时的损失函数变化情况
    + 内部逻辑：
      + 首先创建了三个数组x，y和v，它们分别存储历史数据中的位置和损失值，然后遍历p_hist,J_hist，将每一步的位置和损失值分别存储到这些数组中
      + 创建一个新的图形对象fig，并设置其大小为（12，5），然后我们使用add_gridspec() 方法创建了一个网格布局，将图形分为一行五列，接下来我们使用suptitle() 添加了图形的总标题，解释了在学习率过大时损失如何增加
      + 添加了一个子图，将其放置在网格布局的前两列。我们设定一个固定的b值为100，并在一系列w值上计算对应的损失值，将其绘制成曲线图，然后我们将历史数据中的位置和损失值绘制在同一张图上，以显示学习过程的移动轨迹。我们还设置了子图的标题，坐标轴等标签和主刻度定位器
      + 创建了第二个子图ax，并将其放置在网格布局的第三列以及其之后，我们使用meshgrid（）创建了w和b的网格矩阵，计算每个点的损失值，并将其绘制成3D曲面图，然后，我们设置了子图的坐标轴标签，标题和视角，最后将历史数据中的位置和损失值绘制在曲面图上，以展示学习过程中的移动轨迹
  + add_line : 用于在图形中添加**导数线**，用于表示损失函数在某一点处的斜率
    + 参数：
      + dj_dx: 斜率值，表示损失函数在x1处的导数值
      + x1，y1 ：导数线的起点坐标
      + d： 导数线的长度
      + ax： 要添加导数线的坐标轴对象
    + 内部逻辑：
      + 首先使用np.linspace() 生成一个包含50个点的数组x，这些点的范围从x1-d 到x1+d ，用于构建导数线的横坐标，然后，根据 y = m*(x-x1) + y1 我们计算出对应纵坐标数组y
      + 接着，我们在图形上使用ax.scatter() 方法标记导数线的起点(x1,y1) 颜色为深蓝色，点的大小为50
      + 然后，我们使用ax.plot() 方法绘制导数线，指定线型为虚线，颜色为深红色，zorder 参数指定绘图顺序 ，linewidth参数指定线宽
      + 最后，我们使用ax.annotate 在导数线的起点（x1,y1）处添加文字注释，注释内容为斜率的值，我们使用条件表达式来决定文字注释的水平偏移量，如果起点横坐标为200，则偏移量为30，否则为10，这样可以根据情况调整注释的位置，避免文字重叠
  + plt_gradients : 用来可视化**梯度下降的损失函数和梯度的**
    + 参数分析：
      + 接收四个参数，x_train 和 y_train 是训练数据集，f_compute_cost 是计算损失函数的函数，f_compute_gradient 是计算梯度的函数
    + 内部逻辑：
      + 首先创建了一个图形对象fig，和包含两个子图的坐标轴数组ax，子图大小为（12，4）
      + 在第一个子图中，绘制了损失函数与w的关系图，用以观察损失函数的最小值，通过f_compute_cost 计算每个w对应的损失值，然后使用ax[0].plot() 绘制线条
      + 在第一个子图中，绘制了损失函数的梯度线，对于固定的b=100，计算在几个不同w值下的梯度，然后使用add_line() 来绘制梯度线
      + 在第二个子图中，创建了一个网格，用于在坐标轴上绘制梯度矢量场
      + 计算网络上每个点的梯度，用于绘制梯度矢量
      + 定义变量X和Y 分别表示网格上的w和b，color_array 用于绘制梯度箭头的颜色数组
      + 在第二个子图中，绘制梯度矢量场，使用ax[1].quiver() 绘制箭头，ax[1].quiverkey()添加箭头的说明
  + compute_cost_matrix(X, y, w, b, verbose=False) : 计算线性回归的成本（损失）函数
    + f_wb = X @ w + b
      + X 是输入特征矩阵，每行代表一个样本，每列代表一个特征
      + w 是模型的权重参数向量，长度等于特征数目
      + b 是模型的截距参数
      + @ 符号表示矩阵乘法运算，X @ w 表示将输入特征矩阵X 与权重参数向量w 进行矩阵乘法运算，得到一个包含每个样本的的预测结果的向量
  + compute_gradient_matrix(X, y, w, b): 计算线性回归的梯度
    + 它接收输入特征矩阵X，目标值向量y， 模型参数w和截距b，并返回成本函数对参数w和b的梯度。
    + 使用矩阵运算来实现更高效的计算
    + 逻辑解析：
      + m,n = X.shape: 获取输入特征矩阵X的形状，其中m是样本数量，n是特征数量
      + f_wb = X @ w + b 计算模型预测结果
      + e = f_wb - y 计算预测值与真实标签之间的误差
      + dj_dw = (1/m) * (X.T @ e)： 计算成本函数对权重参数w的梯度，X.T 表示X的转置矩阵，@ 表示矩阵乘法，这一行实际上是应用了成本函数的梯度公式，通过将误差向量e 与输入特征矩阵X 进行矩阵乘法得到梯度向量
      + dj_db = (1/m) * np.sum(e)：计算成本函数对截距参数 b 的梯度。这是误差向量 e 的平均值。
  + compute_cost : 用于计算该w下的损失函数（成本函数）
  + compute_gradient : 用代数的方式来计算梯度
+ C1_W1_L5:
  + gradient_descent :
    + 参数解析：
      + x：输入数据（m个示例）
      + y: 目标值
      + w_in,b_in: 模型参数的初始值
      + alpha: 学习率
      + num_iters: 运行梯度下降的迭代次数
      + cost_function: 计算成本的函数
      + gradient_function :计算梯度的函数
    + 返回值解析：
      + w： 运行梯度下降之后更新的参数值
      + n： 运行梯度下降后更新的参数值
      + J_history: 成本值得历史记录
      + p_history: 参数[w,b] 的历史纪录
    + 内部逻辑：
      + 首先将输入的参数深拷贝给局部变量w，以避免在函数内部修改全局变量w_in
      + 初始化用于存储成本J和参数w的数组J_history,p_history ，以及将输入参数b_in ，w_in 分配给局部变量b和w
      + 开始迭代num_iters 次
      + 使用梯度函数gradient_funtion 计算梯度，并将结果赋值给dj_dw 和dj_db
      + 使用梯度下降更新参数b和w
      + 在每次迭代中，计算成本并将其附加到J_history ，同时将当前参数[w,b] 附加到p_history 这样可以记录下整个优化过程的参数和成本值
      + 每隔一定时间间隔打印当前的成本值，梯度信息和参数值，以便在优化过程中跟踪进展